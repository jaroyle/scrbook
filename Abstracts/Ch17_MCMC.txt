
In this chapter we will dive a little deeper into Markov chain Monte
Carlo (MCMC) sampling. We will construct custom MCMC samplers in {\bf
  R}, starting with easy-to-code GLMs and GLMMs and moving on to
simple CR and SCR models. 

knowing how to build an MCMC sampler is not essential for any of the
SCR models we have covered so far, but we will need these skills to
implement some models that come up in the last few chapters of this
book. The aim of this chapter is to provide you with some working
knowledge of building MCMC samplers. 


The standard programs we have used so far to do MCMC analyses are
{\bf WinBUGS} \citep{gilks_etal:1994} and {\bf JAGS}
\citep{plummer:2003}. The wonderful thing about these {\bf BUGS}
engines
is that they automatically use  appropriate and, most of the time, reasonably
efficient forms
of MCMC sampling for the model specified by the user.

The fact that we have such a Swiss Army knife type of MCMC machine
begs the question: Why would anyone want to build their own MCMC
algorithm? For one, there are a limited number of distributions and
functions implemented in {\bf BUGS}. While {\bf OpenBUGS} and {\bf JAGS} provide more
options, some more complex models may be impossible to build within
these programs. A very simple example from spatial capture-recapture
that can give you a headache in {\bf WinBUGS} is when your state-space is an
irregular-shaped polygon, rather than an ideal rectangle that can be
characterized by four pairs of coordinates. It is easy to restrict
activity centers to any arbitrary polygon in {\bf R} using an ESRI shapefile
(and we will show you an example in a little bit), but you cannot use
a shapefile in a {\bf BUGS} model.  Similarly, models of space usage
that take into account ecological distance
(Chapt. \ref{chapt.ecoldist}) cannot be implemented in the {\bf BUGS}
engines.

Sometimes, implementing an MCMC algorithm in {\bf R} may be faster than in
{\bf WinBUGS} , and flexibility in tuning algorithsm...........

Finally, building your own MCMC algorithm is a great exercise to
understand how MCMC sampling works. So while using the {\bf BUGS}
language requires you to understand the structure of your model,
building an MCMC algorithm requires you to think about the
relationship between your data, priors and posteriors, and how these
can be efficiently analyzed and characterized.  However, if you
don't think you will ever sit down and write your own MCMC sampler,
consider skipping this chapter - apart from coding it will not cover
anything SCR-related that is not covered by other, more model-oriented
chapters as well.


1. why build your own algorithm...

2. concepts: mcmc and posterior sampling


3. types of mcmc sampling (Gibbs sampling, M-H, etc..)

4. example using model Mh

5. what to do with posterior output/summarizing posterior output... plots of various sorts, etc..

6. example with SCR with flexible shape state-space, defined by
a shapefile.

7. Methoes for inreasing computational speed -- taking advantage of
multiple cores using the snowfall package...  C++ etc..


Key words:
Markov chain Monte Carlo,
Posterior simulation,
Gibbs sampling,
Metropolis-Hastings,
Metrpolis-within-Gibbs,
rejection sampling,
slice sampling,
parallel computing,
cluster computing, 
C++,
