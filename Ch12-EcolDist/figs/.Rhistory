parameters <- c("psi","sigma","p0","N","D","beta","Xobs","Xnew","alpha2") ###,"Xobs","Xnew","s","w")
out <- bugs(data, inits, parameters, "modelfile.txt", n.thin=1,n.chains=3, n.burnin=nb,n.iter=ni,working.dir=getwd(),debug=FALSE)
out
}
toad3<-wolvSCR0pois3d.fn(y3d,traps,nb=1000,ni=1200,delta=2,M=100)
wolvSCR0pois3d.fn <-
function(y3d,traps,nb=1000,ni=2000,delta=2,M=200){
library("R2WinBUGS")
# trapping grid scaled appropriately
traplocs<-as.matrix(traps[,1:2])
mingridx<-min(traplocs[,1])
mingridy<-min(traplocs[,2])
traplocs[,1]<-traplocs[,1] -min(traplocs[,1])
traplocs[,2]<-traplocs[,2]- min(traplocs[,2])
traplocs<-traplocs/10000 ###units of 10 km
ntraps<- nrow(traplocs)
## set the state-space
Xl<-min(traplocs[,1] - delta)
Xu<-max(traplocs[,1] + delta)
Yl<-min(traplocs[,2] - delta)
Yu<-max(traplocs[,2] + delta)
area<- (Xu-Xl)*(Yu-Yl)/10
plot(traplocs,pch=20,xlim=c(Xl,Xu),ylim=c(Yl,Yu))
### ARRAY having dimensions individual x rep x trap
## MASK is trap x rep
nz<-M-dim(y3d)[1]
MASK<-traps[,3:ncol(traps)]
Dmat<-as.matrix(dist(traplocs))
nind<-dim(y3d)[1]
nreps<-dim(y3d)[2]
K<-dim(y3d)[2]
## Data Augmentation
newy<-array(0,dim=c(nind+nz,K,ntraps))
for(j in 1:nind){
newy[j,1:K,1:ntraps]<-y3d[j,1:K,1:ntraps]
}
y3d<-newy
B<-array(0,dim=dim(y3d))
for(i in 1:dim(y3d)[1]){
for(j in 1:dim(y3d)[3]){
xx<-y3d[i,,j]
if(any(xx>0)){
 fst<- (1:length(xx))[xx==1][1]
 B[i,(fst+1):length(xx),j]<-1
}
}
}
M<-nind+nz
# compute trap-specific sample size
K<-apply(MASK,1,sum)
ncaps<- apply(y3d,c(1,3),sum)
y<-y3d
sink("modelfile.txt")
cat("
model {
#beta~dnorm(0,.01)
sigma~dunif(0,50)
p0~dunif(0,1)
logitp0<-log(p0/(1-p0))
beta<- (1/(2*sigma*sigma) )
alpha2 ~ dnorm(0,.1)
psi ~ dunif(0,1)
for(i in 1:M){
 w[i]~dbern(psi)
 s[i,1]~dunif(Xl,Xu)
 s[i,2]~dunif(Yl,Yu) 
}
for(i in 1:M){
for(j in 1:ntraps){
 dd[i,j]<- pow(s[i,1] - traplocs[j,1],2)  + pow(s[i,2] - traplocs[j,2],2) 
for(k in 1:nreps){
logit(pbase[i,k,j])<- logitp0 + alpha2*B[i,k,j]
   mu[i,k,j]<-w[i]*p[i,k,j]
 y[i,k,j]~ dpois(mu[i,k,j]) 
  p[i,k,j]  <-  pbase[i,k,j]*exp( - beta*dd[i,j] )
ncapsnew[i,k,j]~dpois(mu[i,k,j])
err[i,k,j]<-  pow(pow(y[i,k,j],.5) - pow(mu[i,k,j],.5),2)
errnew[i,k,j]<- pow(pow(ncapsnew[i,k,j],.5) - pow(mu[i,k,j],.5),2)
}
}
}
#for(j in 1:ntraps){
#traptotals[j]<-sum(ncapsnew[1:M,j])
#}
Xobs<-sum(err[,,])
Xnew<-sum(errnew[,,])
N<-sum(w[1:M])
D<-N/area
}
",fill=TRUE)
sink()
data <- list ("y","traplocs","M","ntraps","K","Xl","Xu","Yl","Yu","area","nreps","B")
sst<-sample(1:nrow(traplocs),M,replace=TRUE)
wst<-c(rep(1,nind),rep(0,M-nind))
inits <- function(){
  list (sigma=runif(1,.4,1),p0=runif(1,.01,.2),w=wst,alpha2=0)
}
parameters <- c("psi","sigma","p0","N","D","beta","Xobs","Xnew","alpha2") ###,"Xobs","Xnew","s","w")
out <- bugs(data, inits, parameters, "modelfile.txt", n.thin=1,n.chains=3, n.burnin=nb,
n.iter=ni,working.dir=getwd(),debug=TRUE)
out
}
toad3<-wolvSCR0pois3d.fn(y3d,traps,nb=1000,ni=1200,delta=2,M=100)
wolvSCR0pois3d.fn <-
function(y3d,traps,nb=1000,ni=2000,delta=2,M=200){
library("R2WinBUGS")
# trapping grid scaled appropriately
traplocs<-as.matrix(traps[,1:2])
mingridx<-min(traplocs[,1])
mingridy<-min(traplocs[,2])
traplocs[,1]<-traplocs[,1] -min(traplocs[,1])
traplocs[,2]<-traplocs[,2]- min(traplocs[,2])
traplocs<-traplocs/10000 ###units of 10 km
ntraps<- nrow(traplocs)
## set the state-space
Xl<-min(traplocs[,1] - delta)
Xu<-max(traplocs[,1] + delta)
Yl<-min(traplocs[,2] - delta)
Yu<-max(traplocs[,2] + delta)
area<- (Xu-Xl)*(Yu-Yl)/10
plot(traplocs,pch=20,xlim=c(Xl,Xu),ylim=c(Yl,Yu))
### ARRAY having dimensions individual x rep x trap
## MASK is trap x rep
nz<-M-dim(y3d)[1]
MASK<-traps[,3:ncol(traps)]
Dmat<-as.matrix(dist(traplocs))
nind<-dim(y3d)[1]
K<-dim(y3d)[2]
## Data Augmentation
newy<-array(0,dim=c(nind+nz,K,ntraps))
for(j in 1:nind){
newy[j,1:K,1:ntraps]<-y3d[j,1:K,1:ntraps]
}
y3d<-newy
B<-array(0,dim=dim(y3d))
for(i in 1:dim(y3d)[1]){
for(j in 1:dim(y3d)[3]){
xx<-y3d[i,,j]
if(any(xx>0)){
 fst<- (1:length(xx))[xx==1][1]
 B[i,(fst+1):length(xx),j]<-1
}
}
}
M<-nind+nz
# compute trap-specific sample size
K<-apply(MASK,1,sum)
ncaps<- apply(y3d,c(1,3),sum)
y<-y3d
sink("modelfile.txt")
cat("
model {
#beta~dnorm(0,.01)
sigma~dunif(0,50)
p0~dunif(0,1)
logitp0<-log(p0/(1-p0))
beta<- (1/(2*sigma*sigma) )
alpha2 ~ dnorm(0,.1)
psi ~ dunif(0,1)
for(i in 1:M){
 w[i]~dbern(psi)
 s[i,1]~dunif(Xl,Xu)
 s[i,2]~dunif(Yl,Yu) 
}
for(i in 1:M){
for(j in 1:ntraps){
 dd[i,j]<- pow(s[i,1] - traplocs[j,1],2)  + pow(s[i,2] - traplocs[j,2],2) 
for(k in 1:K){
logit(pbase[i,k,j])<- logitp0 + alpha2*B[i,k,j]
   mu[i,k,j]<-w[i]*p[i,k,j]
 y[i,k,j]~ dpois(mu[i,k,j]) 
  p[i,k,j]  <-  pbase[i,k,j]*exp( - beta*dd[i,j] )
ncapsnew[i,k,j]~dpois(mu[i,k,j])
err[i,k,j]<-  pow(pow(y[i,k,j],.5) - pow(mu[i,k,j],.5),2)
errnew[i,k,j]<- pow(pow(ncapsnew[i,k,j],.5) - pow(mu[i,k,j],.5),2)
}
}
}
#for(j in 1:ntraps){
#traptotals[j]<-sum(ncapsnew[1:M,j])
#}
Xobs<-sum(err[,,])
Xnew<-sum(errnew[,,])
N<-sum(w[1:M])
D<-N/area
}
",fill=TRUE)
sink()
data <- list ("y","traplocs","M","ntraps","K","Xl","Xu","Yl","Yu","area","B")
sst<-sample(1:nrow(traplocs),M,replace=TRUE)
wst<-c(rep(1,nind),rep(0,M-nind))
inits <- function(){
  list (sigma=runif(1,.4,1),p0=runif(1,.01,.2),w=wst,alpha2=0)
}
parameters <- c("psi","sigma","p0","N","D","beta","Xobs","Xnew","alpha2") ###,"Xobs","Xnew","s","w")
out <- bugs(data, inits, parameters, "modelfile.txt", n.thin=1,n.chains=3, n.burnin=nb,
n.iter=ni,working.dir=getwd(),debug=TRUE)
out
}
toad3<-wolvSCR0pois3d.fn(y3d,traps,nb=1000,ni=1200,delta=2,M=100)
dim(MASK)
wolverine$wtraps
wolverine$wtraps[1,]
wolvSCR0pois3d.fn <-
function(y3d,traps,nb=1000,ni=2000,delta=2,M=200){
library("R2WinBUGS")
# trapping grid scaled appropriately
traplocs<-as.matrix(traps[,1:2])
mingridx<-min(traplocs[,1])
mingridy<-min(traplocs[,2])
traplocs[,1]<-traplocs[,1] -min(traplocs[,1])
traplocs[,2]<-traplocs[,2]- min(traplocs[,2])
traplocs<-traplocs/10000 ###units of 10 km
ntraps<- nrow(traplocs)
## set the state-space
Xl<-min(traplocs[,1] - delta)
Xu<-max(traplocs[,1] + delta)
Yl<-min(traplocs[,2] - delta)
Yu<-max(traplocs[,2] + delta)
area<- (Xu-Xl)*(Yu-Yl)/10
plot(traplocs,pch=20,xlim=c(Xl,Xu),ylim=c(Yl,Yu))
### ARRAY having dimensions individual x rep x trap
## MASK is trap x rep
nz<-M-dim(y3d)[1]
MASK<-traps[,3:ncol(traps)]
Dmat<-as.matrix(dist(traplocs))
nind<-dim(y3d)[1]
K<-dim(y3d)[2]
## Data Augmentation
newy<-array(0,dim=c(nind+nz,K,ntraps))
for(j in 1:nind){
newy[j,1:K,1:ntraps]<-y3d[j,1:K,1:ntraps]
}
y3d<-newy
B<-array(0,dim=dim(y3d))
for(i in 1:dim(y3d)[1]){
for(j in 1:dim(y3d)[3]){
xx<-y3d[i,,j]
if(any(xx>0)){
 fst<- (1:length(xx))[xx==1][1]
 B[i,(fst+1):length(xx),j]<-1
}
}
}
M<-nind+nz
# compute trap-specific sample size
#K<-apply(MASK,1,sum)
ncaps<- apply(y3d,c(1,3),sum)
y<-y3d
sink("modelfile.txt")
cat("
model {
#beta~dnorm(0,.01)
sigma~dunif(0,50)
p0~dunif(0,1)
logitp0<-log(p0/(1-p0))
beta<- (1/(2*sigma*sigma) )
alpha2 ~ dnorm(0,.1)
psi ~ dunif(0,1)
for(i in 1:M){
 w[i]~dbern(psi)
 s[i,1]~dunif(Xl,Xu)
 s[i,2]~dunif(Yl,Yu) 
}
for(i in 1:M){
for(j in 1:ntraps){
 dd[i,j]<- pow(s[i,1] - traplocs[j,1],2)  + pow(s[i,2] - traplocs[j,2],2) 
for(k in 1:K){
logit(pbase[i,k,j])<- logitp0 + alpha2*B[i,k,j]
   mu[i,k,j]<-w[i]*p[i,k,j]*MASK[j,k]
 y[i,k,j]~ dpois(mu[i,k,j]) 
  p[i,k,j]  <-  pbase[i,k,j]*exp( - beta*dd[i,j] )
ncapsnew[i,k,j]~dpois(mu[i,k,j])
err[i,k,j]<-  pow(pow(y[i,k,j],.5) - pow(mu[i,k,j],.5),2)
errnew[i,k,j]<- pow(pow(ncapsnew[i,k,j],.5) - pow(mu[i,k,j],.5),2)
}
}
}
#for(j in 1:ntraps){
#traptotals[j]<-sum(ncapsnew[1:M,j])
#}
Xobs<-sum(err[,,])
Xnew<-sum(errnew[,,])
N<-sum(w[1:M])
D<-N/area
}
",fill=TRUE)
sink()
data <- list ("y","traplocs","M","ntraps","K","Xl","Xu","Yl","Yu","area","B","MASK")
sst<-sample(1:nrow(traplocs),M,replace=TRUE)
wst<-c(rep(1,nind),rep(0,M-nind))
inits <- function(){
  list (sigma=runif(1,.4,1),p0=runif(1,.01,.2),w=wst,alpha2=0)
}
parameters <- c("psi","sigma","p0","N","D","beta","Xobs","Xnew","alpha2") ###,"Xobs","Xnew","s","w")
out <- bugs(data, inits, parameters, "modelfile.txt", n.thin=1,n.chains=3, n.burnin=nb,
n.iter=ni,working.dir=getwd(),debug=TRUE)
out
}
toad3<-wolvSCR0pois3d.fn(y3d,traps,nb=1000,ni=1200,delta=2,M=100)
wolvSCR0pois3d.fn <-
function(y3d,traps,nb=1000,ni=2000,delta=2,M=200){
library("R2WinBUGS")
# trapping grid scaled appropriately
traplocs<-as.matrix(traps[,1:2])
mingridx<-min(traplocs[,1])
mingridy<-min(traplocs[,2])
traplocs[,1]<-traplocs[,1] -min(traplocs[,1])
traplocs[,2]<-traplocs[,2]- min(traplocs[,2])
traplocs<-traplocs/10000 ###units of 10 km
ntraps<- nrow(traplocs)
## set the state-space
Xl<-min(traplocs[,1] - delta)
Xu<-max(traplocs[,1] + delta)
Yl<-min(traplocs[,2] - delta)
Yu<-max(traplocs[,2] + delta)
area<- (Xu-Xl)*(Yu-Yl)/10
plot(traplocs,pch=20,xlim=c(Xl,Xu),ylim=c(Yl,Yu))
### ARRAY having dimensions individual x rep x trap
## MASK is trap x rep
nz<-M-dim(y3d)[1]
MASK<-as.matrix(traps[,3:ncol(traps)])
Dmat<-as.matrix(dist(traplocs))
nind<-dim(y3d)[1]
K<-dim(y3d)[2]
## Data Augmentation
newy<-array(0,dim=c(nind+nz,K,ntraps))
for(j in 1:nind){
newy[j,1:K,1:ntraps]<-y3d[j,1:K,1:ntraps]
}
y3d<-newy
B<-array(0,dim=dim(y3d))
for(i in 1:dim(y3d)[1]){
for(j in 1:dim(y3d)[3]){
xx<-y3d[i,,j]
if(any(xx>0)){
 fst<- (1:length(xx))[xx==1][1]
 B[i,(fst+1):length(xx),j]<-1
}
}
}
M<-nind+nz
# compute trap-specific sample size
#K<-apply(MASK,1,sum)
ncaps<- apply(y3d,c(1,3),sum)
y<-y3d
sink("modelfile.txt")
cat("
model {
#beta~dnorm(0,.01)
sigma~dunif(0,50)
p0~dunif(0,1)
logitp0<-log(p0/(1-p0))
beta<- (1/(2*sigma*sigma) )
alpha2 ~ dnorm(0,.1)
psi ~ dunif(0,1)
for(i in 1:M){
 w[i]~dbern(psi)
 s[i,1]~dunif(Xl,Xu)
 s[i,2]~dunif(Yl,Yu) 
}
for(i in 1:M){
for(j in 1:ntraps){
 dd[i,j]<- pow(s[i,1] - traplocs[j,1],2)  + pow(s[i,2] - traplocs[j,2],2) 
for(k in 1:K){
logit(pbase[i,k,j])<- logitp0 + alpha2*B[i,k,j]
   mu[i,k,j]<-w[i]*p[i,k,j]*MASK[j,k]
 y[i,k,j]~ dpois(mu[i,k,j]) 
  p[i,k,j]  <-  pbase[i,k,j]*exp( - beta*dd[i,j] )
ncapsnew[i,k,j]~dpois(mu[i,k,j])
err[i,k,j]<-  pow(pow(y[i,k,j],.5) - pow(mu[i,k,j],.5),2)
errnew[i,k,j]<- pow(pow(ncapsnew[i,k,j],.5) - pow(mu[i,k,j],.5),2)
}
}
}
#for(j in 1:ntraps){
#traptotals[j]<-sum(ncapsnew[1:M,j])
#}
Xobs<-sum(err[,,])
Xnew<-sum(errnew[,,])
N<-sum(w[1:M])
D<-N/area
}
",fill=TRUE)
sink()
data <- list ("y","traplocs","M","ntraps","K","Xl","Xu","Yl","Yu","area","B","MASK")
sst<-sample(1:nrow(traplocs),M,replace=TRUE)
wst<-c(rep(1,nind),rep(0,M-nind))
inits <- function(){
  list (sigma=runif(1,.4,1),p0=runif(1,.01,.2),w=wst,alpha2=0)
}
parameters <- c("psi","sigma","p0","N","D","beta","Xobs","Xnew","alpha2") ###,"Xobs","Xnew","s","w")
out <- bugs(data, inits, parameters, "modelfile.txt", n.thin=1,n.chains=3, n.burnin=nb,
n.iter=ni,working.dir=getwd(),debug=TRUE)
out
}
toad3<-wolvSCR0pois3d.fn(y3d,traps,nb=1000,ni=1200,delta=2,M=100)
library("scrbook")
### Grab a covariate
library("scrbook")
out<-make.EDcovariates()
covariate<-out$covariate.patchy
set.seed(2013)
### prescribe some settings
N<-200
alpha0<- -2
sigma<- .5
alpha1<- 1/(2*sigma*sigma)
alpha2<-1
K<- 5
S<-cbind(runif(N,.5,4.5),runif(N,.5,4.5))
# make up some trap locations
xg<-seq(1,4,1); yg<-4:1
traplocs<-cbind( sort(rep(xg,4)),rep(yg,4))
points(traplocs,pch=20,col="red")
ntraps<-nrow(traplocs)
### make a raster and fill it up with the "cost"
r<-raster(nrows=20,ncols=20)
projection(r)<- "+proj=utm +zone=12 +datum=WGS84"
extent(r)<-c(.5,4.5,.5,4.5)
cost<- exp(alpha2*covariate)
### compute 
tr1<-transition(cost,transitionFunction=function(x) 1/mean(x),directions=8)
tr1CorrC<-geoCorrection(tr1,type="c",multpl=FALSE,scl=FALSE)
D<-costDistance(tr1CorrC,S,traplocs)
probcap<-plogis(alpha0)*exp(-alpha1*D*D)
# now generate the encounters of every individual in every trap
Y<-matrix(NA,nrow=N,ncol=ntraps)
for(i in 1:nrow(Y)){
 Y[i,]<-rbinom(ntraps,K,probcap[i,])
}
Y<-Y[apply(Y,1,sum)>0,]
\end{verbatim}
intlik3ed
?intlik3ed
?intlik3ed
frog1<-nlm(intlik3ed,c(alpha0,alpha1,log(n0)),hessian=TRUE,y=Y,K=K,X=traplocs,
               distmet="euclid",covariate=covariate,alpha2=1)
frog2<-nlm(intlik3ed,c(alpha0,alpha1,log(n0),-.3),hessian=TRUE,y=Y,K=K,
               X=traplocs,distmet="ecol",covariate=covariate,alpha2=NA)
n0<- N-nrow(Y)
frog1<-nlm(intlik3ed,c(alpha0,alpha1,log(n0)),hessian=TRUE,y=Y,K=K,X=traplocs,
               distmet="euclid",covariate=covariate,alpha2=1)
frog2<-nlm(intlik3ed,c(alpha0,alpha1,log(n0),-.3),hessian=TRUE,y=Y,K=K,
               X=traplocs,distmet="ecol",covariate=covariate,alpha2=NA)
frog1
frog2
n0
log(104)
data("fakecorridor")
library("sp")
library("rgeos")
buffer<- 0.5
par(mfrow=c(1,1))
aa<-gUnion(l1,l2)
plot(gBuffer(aa,width=buffer),xlim=c(0,10),ylim=c(0,10))
pg<-gBuffer(aa,width=buffer)
pg.coords<- pg@polygons[[1]]@Polygons[[1]]@coords
xg<-seq(0,10,,40)
yg<-seq(10,0,,40)
delta<-mean(diff(xg))
pts<- cbind(sort(rep(xg,40)),rep(yg,40))
points(pts,pch=20)
in.pts<-point.in.polygon(pts[,1],pts[,2],pg.coords[,1],pg.coords[,2])
points(pts[in.pts==1,],pch=20,col="red")
dev.off()
data("fakecorridor")
library("sp")
library("rgeos")
buffer<- 0.5
par(mfrow=c(1,1))
aa<-gUnion(l1,l2)
plot(gBuffer(aa,width=buffer),xlim=c(0,10),ylim=c(0,10))
pg<-gBuffer(aa,width=buffer)
pg.coords<- pg@polygons[[1]]@Polygons[[1]]@coords
xg<-seq(0,10,,40)
yg<-seq(10,0,,40)
delta<-mean(diff(xg))
pts<- cbind(sort(rep(xg,40)),rep(yg,40))
points(pts,pch=20)
in.pts<-point.in.polygon(pts[,1],pts[,2],pg.coords[,1],pg.coords[,2])
points(pts[in.pts==1,],pch=20,col="red")
data("fakecorridor")
library("sp")
library("rgeos")
buffer<- 0.5
par(mfrow=c(1,1))
aa<-gUnion(l1,l2)
plot(gBuffer(aa,width=buffer),xlim=c(0,10),ylim=c(0,10))
pg<-gBuffer(aa,width=buffer)
pg.coords<- pg@polygons[[1]]@Polygons[[1]]@coords
xg<-seq(0,10,,40)
yg<-seq(10,0,,40)
delta<-mean(diff(xg))
pts<- cbind(sort(rep(xg,40)),rep(yg,40))
points(pts,pch=20,cex=.5)
data("fakecorridor")
library("sp")
library("rgeos")
buffer<- 0.5
par(mfrow=c(1,1))
aa<-gUnion(l1,l2)
plot(gBuffer(aa,width=buffer),xlim=c(0,10),ylim=c(0,10))
pg<-gBuffer(aa,width=buffer)
pg.coords<- pg@polygons[[1]]@Polygons[[1]]@coords
xg<-seq(0,10,,40)
yg<-seq(10,0,,40)
delta<-mean(diff(xg))
pts<- cbind(sort(rep(xg,40)),rep(yg,40))
points(pts,pch=20,cex=.5)
in.pts<-point.in.polygon(pts[,1],pts[,2],pg.coords[,1],pg.coords[,2])
points(pts[in.pts==1,],pch=20,col="red")
